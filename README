Assignment:     Project 1
Student:        Connor Zanin

Notes:

HOW TO RUN:
        make clean && make

        ./prj1 -h <hostfile> -p <port> -c <count> -s <snapshot time>

        The program has two optional parameters, '-s' to snapshot and '-t' to indicate initial timeout value.
        -s is -1 by default (don't snapshot).
        -t is 10,000 by default.
        Experiments (results in results-timeouts.csv) show this to be near-optimal.

        When the program is done, 'kill -2 <pid>' to print the hold-back buffer to stdout.
        Snapshots are written to 'snap.<pid>' in the current working directory (pid is for processes in the service, not the pid assigned by the operating system).

ARCHITECTURE
        `main.c` is meant to act as a client to the multicast service.
        The main body of the service is implemented in `channel.c`.

        The channel has four main interface functions:
        * ch_init() - initialize socket, datastructures
        * ch_fini() - cleanup
        * ch_send(int) - multicast an int
        * ch_recv(int*) - attempt to receive(deliver) a message from the channel
        * ch_ckpt() - snapshot the system

        `queue.*` is a generic queue implementation with sorting and searching

DEBUGGING
	When moving to four nodes, I noticed that initially the messages were sent quickly, but would slow over time.
	Initially I thought this was a symptom of the back-off congestion control.
	After reducing the back-off rate to 1.1, the problem persisted.
	I employed gprof.
	My guess was that frequent invocations of a quicksort function that didn't check for the sorted property were to blame.
	I was correct, and the gprof file can be found in `debugging/sorting.gprof`.

        The problem comes because I need to sort the queue by two comparator functions, one by final_seq for delivery and one by (sender, msg_id) for finding unique messages.
        I could remedy this problem by maintaining two separate queues.
        After all, the queue is nothing more than an array of void pointers, which means overhead is small.
        Delivering multiple messages at once also seems to rememdy the problem as the hold-back queue is drained faster which reduces the number of calls to `q_sort` as well as the size of the queue.

        This problem reveals a more insidious one.
        Even if the sorting function is conflict-free, there is still the possibility that one process will deliver messages in a different order than another.
        This happens because of the way I detect ability to deliver; if there are no undeliverable items in the hold-back queue, then deliver all the others.
        This fixes many cases of delivering older final_seq's before younger once, it does not eliminate all cases.
        One possible solution is to only deliver a message 'm' with sequence number 's' if you have received a message from every other host with a sequence number greater than s.

CHECKPOINTING
        Checkpointing in my system is handled by the same system that sends data messages.
        First, the markers are sent out.
        The initiator waits for all acks, and does retransmissions according to timeouts.
        A recipient of a marker only takes one checkpoint per intitiator and checkpoint id.
        A vector clock is maintained by each recipient that keeps track of the latest checkpoint request from each initiator.

        A checkpoint is not guaranteed to be consistent.
        However, my system is resilient to packet loss, duplication, and reodering.
        If a node receives a data message with a lower msg_id than what it has seen for a particular sender, the message is discarded.
        If a node receives a SeqMessage for a message not in its holdback queue, it is also discarded.

EXPERIMENTS
        I did some testing of various settings related to timeouts and retransmissions.
        The results can be found in results-timeouts.csv.

        Experiments were run on a 4 process cluster where each process sends 500 messages.
        Results of 'number of messages sent' are given for a single node (NOT the sum across all processes).
